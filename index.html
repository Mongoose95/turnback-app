<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>C172M — Turnback, T/O & Mass & Balance (Reggio Emilia)</title>
  <style>
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; margin:0; padding:1rem; color:#111; }
    h1 { font-size:1.1rem; margin:0 0 0.35rem 0; }
    h2 { font-size:1rem; margin:0 0 0.35rem 0; }
    .card { border:1px solid #ddd; border-radius:8px; padding:0.85rem; margin-bottom:1rem; box-shadow:0 1px 3px rgba(0,0,0,0.06); }
    label { display:block; margin-top:0.5rem; font-size:0.9rem; }
    input, select, textarea, button { width:100%; padding:0.45rem; font-size:1rem; box-sizing:border-box; margin-top:0.2rem; }
    textarea { min-height:3rem; font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; }
    .grid { display:grid; grid-template-columns:1fr 1fr; gap:0.5rem 0.75rem; }
    .btn { margin-top:0.6rem; padding:0.6rem; border-radius:6px; border:none; cursor:pointer; }
    .primary { background:#0b6efd; color:#fff; }
    .secondary { background:#e9ecef; color:#111; }
    .small { font-size:0.85rem; color:#555; margin-top:0.35rem; }
    .result { margin-top:0.6rem; font-weight:700; }
    .warning { color:#b00020; font-size:0.8rem; margin-top:0.5rem; }
    .note { font-size:0.82rem; color:#333; margin-top:0.4rem; }
    svg { width:100%; height:170px; border-radius:6px; background:#fafafa; display:block; margin-top:0.6rem; }
    .wx-row { display:flex; gap:0.5rem; margin-top:0.5rem; }
    .wx-row button { flex:1; }
    img.wxchart { width:100%; max-width:1000px; border-radius:8px; display:block; margin-top:0.4rem; border:1px solid #ddd; }
    iframe.osm { width:100%; height:260px; border:1px solid #ddd; border-radius:6px; margin-top:0.5rem; }
    pre.small-pre { white-space:pre-wrap; font-size:0.85rem; color:#444; margin-top:0.35rem; }
    @media(max-width:600px){
      .grid{ grid-template-columns:1fr }
      .wx-row{ flex-direction:column }
    }
  </style>
</head>
<body>
  <h1>C172M — Turnback Safety, T/O Distance & Mass & Balance (Reggio Emilia)</h1>
  <p class="small">
    Campo: Reggio Emilia (elev 152 ft). Aereo: C172M MTOW 2300 lb, best glide 65 kt, bank max 30°.<br>
    <strong>USO DIDATTICO — NON per decisioni operative reali.</strong>
  </p>

  <!-- METAR section -->
  <div class="card">
    <h2>METAR (LIMP / LIPE)</h2>
    <p class="small">
      Incolla i METAR o recuperali con AVWX.<br>
      Temperatura &amp; QNH: media LIMP+LIPE se entrambi disponibili, altrimenti quello presente.<br>
      Vento: preso da LIMP, fallback LIPE.
    </p>

    <label for="metarLIMP">METAR LIMP (Parma)</label>
    <textarea id="metarLIMP" placeholder="METAR LIMP 011850Z 08008KT 9999 FEW030 05/02 Q1020"></textarea>

    <label for="metarLIPE">METAR LIPE (Bologna)</label>
    <textarea id="metarLIPE" placeholder="METAR LIPE 011850Z 09006KT 9999 FEW030 04/01 Q1018"></textarea>

    <div style="display:flex; gap:0.5rem; margin-top:0.5rem;">
      <button class="btn secondary" onclick="extractFromMetars()">Estrai da METAR incollati</button>
      <button class="btn secondary" onclick="fetchMetarsOnline()">Recupera METAR online (AVWX)</button>
    </div>

    <div id="metarStatus" class="small"></div>
  </div>

  <!-- WX charts section: SWLL Italy + OSM -->
  <div class="card">
    <h2>WX Chart — LOW LEVEL ITALY (SWLL)</h2>
    <p class="small">
      Carta significativa del tempo a bassi livelli (SWLL, suolo–FL100) per l’area Italia.<br>
      L’immagine è un file locale <code>swll_italy_latest.png</code> ottenuto dal sito ufficiale
      <strong>MeteoAM</strong> e caricato nel repository.
    </p>

    <img id="swllImg"
         class="wxchart"
         src="swll_italy_latest.png"
         alt="SWLL Italy - low level significant weather">

    <div class="wx-row">
      <button class="btn secondary" onclick="reloadLocalSwll()">Reload immagine</button>
      <button class="btn secondary" onclick="openSwllSource()">Apri MeteoAM SWLL (per aggiornare la carta)</button>
    </div>

    <div class="small" id="swllInfo">
      Source originale: <strong>MeteoAM</strong> — Carta significativa del tempo SWLL Italia.<br>
      Immagine locale: <code>swll_italy_latest.png</code>. Last reload: <span id="swllTime">—</span>
    </div>

    <iframe class="osm"
      src="https://www.openstreetmap.org/export/embed.html?bbox=10.55%2C44.65%2C10.71%2C44.74&layer=mapnik&marker=44.699%2C10.63"
      title="Reggio Emilia map"></iframe>
    <div class="small">
      Mappa: marker centrato su Reggio Emilia. Usa la SWLL per valutare i fenomeni sul Nord Italia / zona Po Valley.
    </div>
  </div>

  <!-- Mass & Balance -->
  <div class="card">
    <h2>Mass & Balance — C172M</h2>
    <p class="small">
      Modello basato sulle tabelle standard C172M (1392 lb empty weight, momento 54&nbsp;600 in·lb).
      Bracci (ARM): pilota/pax fronte 37", pax rear 73", baggage 1 (max 120 lb) 95", baggage 2 (max 40 lb) 123",
      fuel 48". Fuel 6 lb/USG.
    </p>

    <div class="grid">
      <div>
        <label for="mbPilot">Pilota (lb)</label>
        <input id="mbPilot" type="number" />
      </div>
      <div>
        <label for="mbPaxFront">Pax anteriore (lb)</label>
        <input id="mbPaxFront" type="number" />
      </div>
      <div>
        <label for="mbPaxRear">Pax posteriori (totale, lb)</label>
        <input id="mbPaxRear" type="number" />
      </div>
      <div>
        <label for="mbFuel">Fuel utilizzabile (USG)</label>
        <input id="mbFuel" type="number" />
      </div>
      <div>
        <label for="mbBag1">Baggage Area 1 (lb, max 120)</label>
        <input id="mbBag1" type="number" />
      </div>
      <div>
        <label for="mbBag2">Baggage Area 2 (lb, max 40)</label>
        <input id="mbBag2" type="number" />
      </div>
    </div>

    <button class="btn primary" onclick="runMBCalcAndPerf()">Calcola M&B + Performance</button>

    <div id="mbOutput" class="small" style="margin-top:0.5rem;"></div>
  </div>

  <!-- Performance & Safety -->
  <div class="card">
    <h2>Performance & Safety altitude</h2>
    <p class="small">
      Usa gli input meteo, RWY e il <strong>peso corrente</strong> (dall’ultimo calcolo M&amp;B) per stimare:
      safety altitude per turnback, ground roll e distanza a 50 ft. Se non hai ancora calcolato la M&amp;B,
      viene usato un peso di riferimento pari a 2300 lb (MTOW).
    </p>

    <div class="grid">
      <div>
        <label for="temp">Temperatura aria (°C)</label>
        <input id="temp" type="number" value="15" />
      </div>
      <div>
        <label for="qnh">QNH (hPa)</label>
        <input id="qnh" type="number" value="1013" />
      </div>
      <div>
        <label for="windDir">Direzione vento FROM (°)</label>
        <input id="windDir" type="number" placeholder="es. 080" />
      </div>
      <div>
        <label for="windSpeed">Intensità vento (kt)</label>
        <input id="windSpeed" type="number" placeholder="es. 8" />
      </div>
      <div>
        <label for="runway">Pista</label>
        <select id="runway">
          <option value="11">RWY 11 (109°)</option>
          <option value="29">RWY 29 (289°)</option>
        </select>
      </div>
      <div>
        <label for="units">Unità distanza</label>
        <select id="units">
          <option value="ft">Feet</option>
          <option value="m">Meters</option>
        </select>
      </div>
    </div>

    <button class="btn secondary" onclick="calcPerfWithCurrentWeight()">Calcola solo performance (peso corrente)</button>

    <div id="output" style="display:none;">
      <div id="safetyAltText" class="result"></div>
      <div id="commentText" class="small" style="white-space:pre-line;"></div>

      <div class="card" style="margin-top:0.6rem;">
        <div class="small"><strong>Takeoff distances (POH + corrette)</strong></div>
        <div id="distanceText" class="small" style="margin-top:0.35rem;"></div>

        <svg id="runwaySvg" viewBox="0 0 1000 200" preserveAspectRatio="xMidYMid meet">
          <rect x="20" y="70" width="960" height="60" rx="6" fill="#222" opacity="0.06"></rect>
          <g id="centerline" stroke="#bbb" stroke-width="2" stroke-linecap="round"></g>
          <g id="markers"></g>
          <g id="labels" font-family="system-ui, -apple-system" font-size="12" fill="#222"></g>
        </svg>

        <div class="note">
          Base POH: Ground roll = <strong>835 ft</strong>, 50 ft obstacle = <strong>1475 ft</strong> @ 10°C, QNH 1013, no wind, MTOW 2300 lb.<br>
          Modello didattico: ≈ +12% per +1000 ft di DA; vento ≈ ±5% per 5 kt; peso ≈ (W / 2300)<sup>2</sup>.
        </div>
      </div>

      <div style="margin-top:0.5rem;">
        <pre id="calcDetails" class="small-pre"></pre>
      </div>

      <div class="warning">
        TRAINING TOOL ONLY — confronta sempre con POH/AFM e istruttore. NON usare per decisioni operative reali.
      </div>
    </div>
  </div>

<script>
/* ========== CONFIG ========== */
const AVWX_TOKEN = "Z40mhXflUZEQ_xWPCMktcJz5kXX9mBAdBJsY_Jsv6wc";
const SWLL_SOURCE_URL = "https://www.meteoam.it/it/swll";

/* Stato globale del peso corrente */
let lastWeightLb = 2300; // default MTOW

/* ========== HELPERS GENERALI ========== */
function toRad(d){ return d * Math.PI / 180; }

/* ========== SWLL (immagine locale) ========== */
function setSwllTimestamp(ts){
  document.getElementById('swllTime').textContent = ts || (new Date()).toLocaleString();
}
function reloadLocalSwll(){
  const img = document.getElementById('swllImg');
  img.src = "swll_italy_latest.png?_=" + Date.now();
  setSwllTimestamp(new Date().toLocaleString());
}
function openSwllSource(){
  window.open(SWLL_SOURCE_URL, "_blank");
}

/* ========== METAR parsing & fetch ========== */
function parseTempCode(code){
  if(!code) return null;
  code = code.trim();
  let neg = false;
  if(code.startsWith('M')){ neg = true; code = code.slice(1); }
  const n = parseInt(code,10);
  if(isNaN(n)) return null;
  return neg ? -n : n;
}

function parseMetar(metar){
  if(!metar) return null;
  const text = metar.toUpperCase();
  const tempRegex = /\s(M?\d{2})\/(M?\d{2})\s/;
  const tMatch = text.match(tempRegex);
  const qnhRegex = /Q(\d{4})/;
  const qMatch = text.match(qnhRegex);
  let temp = null, qnh = null;
  if(tMatch) temp = parseTempCode(tMatch[1]);
  if(qMatch) qnh = parseInt(qMatch[1],10);
  if(temp === null && qnh === null) return null;
  return { temp, qnh, raw: metar };
}

function extractFromMetars(){
  const limpTxt = document.getElementById('metarLIMP').value;
  const lipeTxt = document.getElementById('metarLIPE').value;
  const status = document.getElementById('metarStatus');

  const limp = parseMetar(limpTxt);
  const lipe = parseMetar(lipeTxt);

  if(!limp && !lipe){
    status.style.color = '#b00020';
    status.textContent = 'Impossibile estrarre T/QNH da METAR incollati.';
    return;
  }

  let avgT, avgQ, msg = '';
  if(limp && lipe && limp.temp !== null && lipe.temp !== null && limp.qnh !== null && lipe.qnh !== null){
    avgT = (limp.temp + lipe.temp) / 2;
    avgQ = (limp.qnh + lipe.qnh) / 2;
    msg = `Media LIMP+LIPE: T≈${avgT.toFixed(1)}°C QNH≈${avgQ.toFixed(0)} hPa.`;
  } else if(limp && limp.temp !== null && limp.qnh !== null){
    avgT = limp.temp; avgQ = limp.qnh;
    msg = `Usato solo LIMP: T ${avgT}°C QNH ${avgQ} hPa.`;
  } else if(lipe && lipe.temp !== null && lipe.qnh !== null){
    avgT = lipe.temp; avgQ = lipe.qnh;
    msg = `Usato solo LIPE: T ${avgT}°C QNH ${avgQ} hPa.`;
  } else {
    status.style.color = '#b00020';
    status.textContent = 'METAR presenti, ma T/QNH non riconosciuti.';
    return;
  }

  document.getElementById('temp').value = avgT.toFixed(1);
  document.getElementById('qnh').value = avgQ.toFixed(0);

  // vento: prefer LIMP, fallback LIPE
  const windRx = / (\d{3})(\d{2,3})KT/;
  const limpWind = limp && limp.raw ? limp.raw.toUpperCase().match(windRx) : null;
  const lipeWind = lipe && lipe.raw ? lipe.raw.toUpperCase().match(windRx) : null;

  if(limpWind){
    document.getElementById('windDir').value = parseInt(limpWind[1],10);
    document.getElementById('windSpeed').value = parseInt(limpWind[2],10);
    msg += ` Vento da LIMP: ${limpWind[1]}° / ${limpWind[2]} kt.`;
  } else if(lipeWind){
    document.getElementById('windDir').value = parseInt(lipeWind[1],10);
    document.getElementById('windSpeed').value = parseInt(lipeWind[2],10);
    msg += ` Vento da LIPE: ${lipeWind[1]}° / ${lipeWind[2]} kt.`;
  } else {
    msg += ' Vento non riconosciuto, inserisci manualmente.';
  }

  status.style.color = '#198754';
  status.textContent = msg;
}

async function fetchSingleMetar(icao){
  if(!AVWX_TOKEN || AVWX_TOKEN === '') throw new Error('AVWX token non impostato');
  const url = `https://avwx.rest/api/metar/${icao}?format=json&token=${AVWX_TOKEN}`;
  const res = await fetch(url);
  if(!res.ok) throw new Error('HTTP ' + res.status);
  const data = await res.json();
  const temp = data.temperature?.value;
  const qnh  = data.altimeter?.value;
  const windDir = data.wind && data.wind.direction && typeof data.wind.direction.value === 'number'
    ? data.wind.direction.value : null;
  const windSpeed = data.wind && data.wind.speed && typeof data.wind.speed.value === 'number'
    ? data.wind.speed.value : null;
  const raw = data.raw || data.sanitized || '';
  return { temp, qnh, windDir, windSpeed, raw };
}

async function fetchMetarsOnline(){
  const status = document.getElementById('metarStatus');
  status.style.color = '#555';
  status.textContent = 'Recupero METAR LIMP + LIPE...';
  const results = {};

  try { results.LIMP = await fetchSingleMetar('LIMP'); } catch(e){ console.log('LIMP err', e); }
  try { results.LIPE = await fetchSingleMetar('LIPE'); } catch(e){ console.log('LIPE err', e); }

  const limpOk = results.LIMP && typeof results.LIMP.temp === 'number' && typeof results.LIMP.qnh === 'number';
  const lipeOk = results.LIPE && typeof results.LIPE.temp === 'number' && typeof results.LIPE.qnh === 'number';

  if(!limpOk && !lipeOk){
    status.style.color = '#b00020';
    status.textContent = 'Nessun METAR utile (T/QNH). Inserisci manualmente o riprova.';
    return;
  }

  let avgT, avgQ, msg = '';
  if(limpOk && lipeOk){
    avgT = (results.LIMP.temp + results.LIPE.temp) / 2;
    avgQ = (results.LIMP.qnh + results.LIPE.qnh) / 2;
    msg = 'Media LIMP+LIPE per T/QNH.';
  } else if(limpOk){
    avgT = results.LIMP.temp; avgQ = results.LIMP.qnh;
    msg = 'Usato solo LIMP per T/QNH.';
  } else {
    avgT = results.LIPE.temp; avgQ = results.LIPE.qnh;
    msg = 'Usato solo LIPE per T/QNH.';
  }

  document.getElementById('temp').value = avgT.toFixed(1);
  document.getElementById('qnh').value = avgQ.toFixed(0);

  if(results.LIMP && typeof results.LIMP.windDir === 'number' && typeof results.LIMP.windSpeed === 'number'){
    document.getElementById('windDir').value = Math.round(results.LIMP.windDir);
    document.getElementById('windSpeed').value = Math.round(results.LIMP.windSpeed);
    msg += ` Vento da LIMP: ${Math.round(results.LIMP.windDir)}° / ${Math.round(results.LIMP.windSpeed)} kt.`;
  } else if(results.LIPE && typeof results.LIPE.windDir === 'number' && typeof results.LIPE.windSpeed === 'number'){
    document.getElementById('windDir').value = Math.round(results.LIPE.windDir);
    document.getElementById('windSpeed').value = Math.round(results.LIPE.windSpeed);
    msg += ` Vento da LIPE: ${Math.round(results.LIPE.windDir)}° / ${Math.round(results.LIPE.windSpeed)} kt.`;
  } else {
    msg += ' Vento non disponibile, inserisci manualmente.';
  }

  if(results.LIMP && results.LIMP.raw) document.getElementById('metarLIMP').value = results.LIMP.raw;
  if(results.LIPE && results.LIPE.raw) document.getElementById('metarLIPE').value = results.LIPE.raw;

  status.style.color = '#198754';
  status.textContent = msg;

  setSwllTimestamp(new Date().toLocaleString());
}

/* ========== MASS & BALANCE C172M ========== */
function computeCG(inputs) {
  const arm = {
    pilot: 37.0,
    paxRear: 73.0,
    bagg1: 95.0,
    bagg2: 123.0,
    fuel: 48.0,
  };

  const fuelGal = inputs.fuel || 0;
  const fuelLbs = fuelGal * 6;

  const weights = {
    ew: 1392,
    pilot: inputs.pilot || 0,
    paxFront: inputs.paxFront || 0,
    paxRear: inputs.paxRear || 0,
    bagg1: inputs.bagg1 || 0,
    bagg2: inputs.bagg2 || 0,
    fuel: fuelLbs,
  };

  const moments = {
    ew: 54600,
    pilot: weights.pilot * arm.pilot,
    paxFront: weights.paxFront * arm.pilot,
    paxRear: weights.paxRear * arm.paxRear,
    bagg1: weights.bagg1 * arm.bagg1,
    bagg2: weights.bagg2 * arm.bagg2,
    fuel: weights.fuel * arm.fuel,
  };

  const totalWeight =
    weights.ew +
    weights.pilot +
    weights.paxFront +
    weights.paxRear +
    weights.bagg1 +
    weights.bagg2 +
    weights.fuel;

  const totalMoment =
    moments.ew +
    moments.pilot +
    moments.paxFront +
    moments.paxRear +
    moments.bagg1 +
    moments.bagg2 +
    moments.fuel;

  const cg = totalMoment / totalWeight;

  return { totalWeight, totalMoment, cg, fuelLbs };
}

function runMBCalcAndPerf(){
  const inputs = {
    pilot: parseFloat(document.getElementById('mbPilot').value) || 0,
    paxFront: parseFloat(document.getElementById('mbPaxFront').value) || 0,
    paxRear: parseFloat(document.getElementById('mbPaxRear').value) || 0,
    bagg1: parseFloat(document.getElementById('mbBag1').value) || 0,
    bagg2: parseFloat(document.getElementById('mbBag2').value) || 0,
    fuel: parseFloat(document.getElementById('mbFuel').value) || 0,
  };

  const r = computeCG(inputs);
  lastWeightLb = r.totalWeight;

  // check envelope (semplificato grossolano)
  let cgStatus = 'CG approssimativamente dentro inviluppo (35"–47").';
  if(r.cg < 35 || r.cg > 47){
    cgStatus = 'ATTENZIONE: CG stimato fuori inviluppo approssimato (35"–47"). Verifica sul grafico ufficiale.';
  }

  const overload = r.totalWeight > 2300 ? `ATTENZIONE: oltre MTOW (2300 lb).` : '';

  const text =
`Total weight stimato: ${Math.round(r.totalWeight)} lb
CG stimato: ${r.cg.toFixed(1)} in from datum
Fuel: ${inputs.fuel.toFixed(1)} USG (${Math.round(r.fuelLbs)} lb)
${cgStatus}
${overload}`;

  document.getElementById('mbOutput').textContent = text;

  // calcola anche performance con questo peso
  calculatePerformance(r.totalWeight);
}

/* Pulsante che usa ultimo peso calcolato o MTOW */
function calcPerfWithCurrentWeight(){
  calculatePerformance(lastWeightLb);
}

/* ========== PERFORMANCE & SAFETY ========== */
function calculatePerformance(weightLb){
  const fieldElev = 152;   // ft
  const baseSafety = 900;  // ft AGL standard
  const baseGroundRoll = 835; // ft
  const base50ft = 1475;      // ft
  const runwayLength_m = 1210;
  const runwayLength_ft = Math.round(runwayLength_m * 3.28084);
  const weightRef = 2300; // MTOW

  if(!weightLb || weightLb <= 0) weightLb = weightRef;

  const temp = parseFloat(document.getElementById('temp').value);
  const qnh  = parseFloat(document.getElementById('qnh').value);
  const windDir = parseFloat(document.getElementById('windDir').value);
  const windSpeed = parseFloat(document.getElementById('windSpeed').value);
  const runway = document.getElementById('runway').value;
  const units  = document.getElementById('units').value;

  if([temp,qnh,windDir,windSpeed].some(v => isNaN(v))){
    alert('Inserisci valori numerici per T, QNH, vento (dir/int).');
    return;
  }

  // Pressure altitude
  const pa = fieldElev + (1013 - qnh) * 30; // ft

  // ISA temp al campo
  const isaTemp = 15 - 2 * (fieldElev / 1000);

  // Density altitude (approx)
  const da = pa + 120 * (temp - isaTemp); // ft
  const daDiff = da - fieldElev;

  const daFactorSafety = 1 + 0.10 * (daDiff / 1000); // +10% / 1000 ft
  const daFactorDist   = 1 + 0.12 * (daDiff / 1000); // +12% / 1000 ft

  // weight factor: distanza ∝ (W/Wref)^2, safety ∝ (W/Wref)
  let weightFactorDist = Math.pow(weightLb / weightRef, 2);
  let weightFactorSafety = weightLb / weightRef;

  if(weightFactorDist < 0.7) weightFactorDist = 0.7;
  if(weightFactorDist > 1.3) weightFactorDist = 1.3;
  if(weightFactorSafety < 0.85) weightFactorSafety = 0.85;
  if(weightFactorSafety > 1.2) weightFactorSafety = 1.2;

  const rwyHeading = runway === '11' ? 109 : 289;
  const angle = toRad(rwyHeading - windDir);
  const headwind = windSpeed * Math.cos(angle); // + headwind, - tailwind

  // wind factors safety
  let windFactorSafety = 1;
  if(headwind < 0){
    const tail = -headwind;
    windFactorSafety = 1 + 0.10 * (tail / 10);
  } else {
    const head = headwind;
    windFactorSafety = 1 - 0.05 * (head / 10);
    if(windFactorSafety < 0.8) windFactorSafety = 0.8;
  }

  // wind factors distanza
  let windDistFactor = 1;
  if(headwind < 0){
    const tail = -headwind;
    windDistFactor = 1 + 0.05 * (tail / 5);
  } else {
    const head = headwind;
    windDistFactor = 1 - 0.05 * (head / 5);
    if(windDistFactor < 0.7) windDistFactor = 0.7;
  }

  const totalDistFactor = daFactorDist * windDistFactor * weightFactorDist;

  const adjGroundRoll_ft = baseGroundRoll * totalDistFactor;
  const adj50ft_ft       = base50ft      * totalDistFactor;

  // safety altitude
  const safetyCalc    = baseSafety * daFactorSafety * windFactorSafety * weightFactorSafety;
  const safetyRounded = Math.round(safetyCalc / 10) * 10;
  const safetySuggested = Math.max(baseSafety, safetyRounded);

  const unitsLabel = units === 'ft' ? 'ft' : 'm';
  const convert = v_ft => units === 'ft' ? v_ft : (v_ft * 0.3048);
  const toFixedVal = v => units === 'ft' ? Math.round(v) : Math.round(v*10)/10;

  document.getElementById('safetyAltText').textContent =
    `Safety altitude (teorica con peso ${Math.round(weightLb)} lb): ${safetyRounded} ft AGL — Minimo operativo suggerito: ${safetySuggested} ft AGL (standard Reggio ${baseSafety} ft).`;

  let comment = '';
  if(safetyRounded < baseSafety){
    comment = `Il calcolo teorico è inferiore allo standard Reggio. Per valutare un turnback in addestramento, considera comunque ${baseSafety} ft come minima safety altitude, anche con peso ${Math.round(weightLb)} lb.`;
  } else if(safetyRounded < 1100){
    comment = `Safety altitude teorica leggermente superiore allo standard, con peso ${Math.round(weightLb)} lb — usa ${safetyRounded} ft come riferimento addestrativo (sempre con margine e valutazione locale).`;
  } else {
    comment = `Safety altitude teorica elevata (DA alta, tailwind e/o peso elevato: ${Math.round(weightLb)} lb). Condizioni sfavorevoli per il turnback: preferibile proseguire dritto salvo training specifico con istruttore.`;
  }
  document.getElementById('commentText').textContent = comment;

  const distText =
`Base POH (10°C, QNH 1013, no wind, 2300 lb):
- Ground roll = ${baseGroundRoll} ft (${Math.round(baseGroundRoll*0.3048)} m)
- 50 ft obstacle = ${base50ft} ft (${Math.round(base50ft*0.3048)} m)

Corretto (DA ≈ ${Math.round(da)} ft, headwind ≈ ${headwind.toFixed(1)} kt, weight ≈ ${Math.round(weightLb)} lb):
- Ground roll ≈ ${toFixedVal(convert(adjGroundRoll_ft))} ${unitsLabel}
- 50 ft obstacle ≈ ${toFixedVal(convert(adj50ft_ft))} ${unitsLabel}
Runway length: ${runwayLength_ft} ft (${runwayLength_m} m).`;

  document.getElementById('distanceText').textContent = distText;

  const details =
`Pressure altitude ≈ ${Math.round(pa)} ft
ISA temp campo ≈ ${isaTemp.toFixed(1)} °C
Density altitude ≈ ${Math.round(da)} ft
DA factor (dist) ≈ ${daFactorDist.toFixed(2)}
Weight factor (dist) ≈ ${weightFactorDist.toFixed(2)}
Wind factor (dist) ≈ ${windDistFactor.toFixed(2)}
Headwind effettivo ≈ ${headwind.toFixed(1)} kt
DA factor (safety) ≈ ${daFactorSafety.toFixed(2)}
Weight factor (safety) ≈ ${weightFactorSafety.toFixed(2)}
Wind factor (safety) ≈ ${windFactorSafety.toFixed(2)}
Adjusted ground roll ≈ ${Math.round(adjGroundRoll_ft)} ft
Adjusted 50 ft ≈ ${Math.round(adj50ft_ft)} ft`;
  document.getElementById('calcDetails').textContent = details;

  drawRunwayDiagram(adjGroundRoll_ft, adj50ft_ft, runwayLength_ft, units);
  document.getElementById('output').style.display = 'block';
}

/* Reset (se vuoi aggiungere un pulsante) */
function resetOutput(){
  document.getElementById('output').style.display = 'none';
  document.getElementById('metarStatus').textContent = '';
}

/* ========== SVG runway schematic ========== */
function drawRunwayDiagram(ground_ft, fifty_ft, rwy_ft, units){
  const svg = document.getElementById('runwaySvg');
  const markers = svg.querySelector('#markers');
  const labels = svg.querySelector('#labels');
  const centerline = svg.querySelector('#centerline');

  while(markers.firstChild) markers.removeChild(markers.firstChild);
  while(labels.firstChild) labels.removeChild(labels.firstChild);
  while(centerline.firstChild) centerline.removeChild(centerline.firstChild);

  const marginLeft = 20;
  const usableW = 960;
  const pxPerFt = usableW / rwy_ft;

  const ground_clamped = Math.min(ground_ft, rwy_ft);
  const fifty_clamped  = Math.min(fifty_ft, rwy_ft);

  const groundPx = Math.max(6, ground_clamped * pxPerFt);
  const fiftyPx  = fifty_clamped * pxPerFt;

  // centerline
  let x = marginLeft + 10;
  const dashW = 12, gap = 8;
  while(x < marginLeft + usableW - 10){
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', x); line.setAttribute('y1', 100);
    line.setAttribute('x2', x + dashW); line.setAttribute('y2', 100);
    line.setAttribute('stroke', '#999'); line.setAttribute('stroke-width', 2);
    centerline.appendChild(line);
    x += dashW + gap;
  }

  // ground roll (blu)
  const gRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
  gRect.setAttribute('x', marginLeft + 6);
  gRect.setAttribute('y', 50);
  gRect.setAttribute('width', groundPx);
  gRect.setAttribute('height', 20);
  gRect.setAttribute('fill', '#0b6efd');
  gRect.setAttribute('opacity', '0.35');
  markers.appendChild(gRect);

  // 50 ft line (rosso)
  const fiftyLine = document.createElementNS('http://www.w3.org/2000/svg','line');
  fiftyLine.setAttribute('x1', marginLeft + 6 + fiftyPx);
  fiftyLine.setAttribute('y1', 40);
  fiftyLine.setAttribute('x2', marginLeft + 6 + fiftyPx);
  fiftyLine.setAttribute('y2', 140);
  fiftyLine.setAttribute('stroke', '#b00020');
  fiftyLine.setAttribute('stroke-width', 2);
  markers.appendChild(fiftyLine);

  const makeText = (txt, x, y, anchor='start', size=12) => {
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('x', x); t.setAttribute('y', y);
    t.setAttribute('fill', '#222'); t.setAttribute('font-size', size);
    t.setAttribute('text-anchor', anchor);
    t.textContent = txt;
    labels.appendChild(t);
  };

  const groundLabelX = marginLeft + Math.min(groundPx, usableW-80) / 2 + 6;
  makeText(`Ground roll ≈ ${formatDist(ground_ft, units)}`, groundLabelX, 46, 'middle', 12);
  makeText(`50 ft ≈ ${formatDist(fifty_ft, units)}`, marginLeft + 6 + fiftyPx, 32, 'middle', 12);

  makeText('Threshold', marginLeft+6, 170, 'start', 11);
  makeText('Runway end', marginLeft+6+usableW, 170, 'end', 11);
  makeText(`${Math.round(rwy_ft)} ft runway`, marginLeft + usableW/2, 170, 'middle', 11);
}

function formatDist(v_ft, units){
  if(units === 'ft') return `${Math.round(v_ft)} ft`;
  const m = Math.round(v_ft * 0.3048 * 10) / 10;
  return `${m} m`;
}

/* init */
setSwllTimestamp(new Date().toLocaleString());
</script>
</body>
</html>
